package AceCouch::Object;

use common::sense;
use AceCouch::Exceptions;

use overload (
    '""'     => 'as_string',
    fallback => 'TRUE',
);

BEGIN {
    *as_string = \&name;
    *isClass   = \&isObject;
}

# TODO: caching results
# TODO: model checking

sub AUTOLOAD {
    our $AUTOLOAD;
    my ($tag) = $AUTOLOAD =~ /.*::(.+)/;
    my $self = shift;

    AC::E::Unimplemented->throw('Using autogenerated accessors on subtrees is not supported/implemented')
        if $self->tree;

    my $fill;

    if (defined $_[0]) {
        given($_[0]) {
            when('-fill') { $fill = 1 }
            default       { AC::E::Unimplemented->throw(
                "Autogenerated accessors do not (yet?) support $_"
            ) }
        }
    }

    my %params = (
        class  => $self->class,
        name   => $self->name,
        tag    => $tag,
        filled => $fill,
    );

    if (wantarray) {
        # does $fill make sense here??
        my $tree = $self->db->fetch(%params, tree => 1);
        my $data = $tree->data;
        return map {
            AceCouch::Object->new_tree($self->db, $_, $data->{$_});
        }
        grep { $_ !~ /^(class|name|_)/ }
        keys %$data;
    }

    return $self->db->fetch(%params);
}

# sub new { # TODO: fix this nastiness
#     my ($class, $args) = @_;

#     return bless $args, $class;
# }

## specific constructors... mild code duplication for now

sub new_unfilled {
    my ($class, $db, $id) = @_;
    my ($c, $n) = AceCouch->id2cn($id);

    return bless { db => $db, id => $id, class => $c, name => $n }, $class;
}

sub new_filled {
    my ($class, $db, $id, $data) = @_;
    my ($c, $n) = AceCouch->id2cn($id);
    delete @{$data}{'class','name'};

    return bless {
        db     => $db,
        id     => $id,
        class  => $c,
        name   => $n,
        filled => 1,
        data   => $data,
    }, $class;
}

sub new_tree {
    my ($class, $db, $id, $data) = @_;
    my ($c, $n) = AceCouch->id2cn($id); # even trees have names and classes...
    delete @{$data}{'class','name'}; # just in case; probably not needed

    return bless {
        db    => $db,
        id    => $id,
        class => $c,
        name  => $n,
        tree  => 1,
        data  => $data,
    }, $class;
}

sub DESTROY {}

# a few things don't make sense if the object is a subtree

sub id     { shift->{id} }
sub name   { shift->{name} }
sub class  { shift->{class} }
sub data   { shift->{data} }
sub db     { shift->{db} }

# convention: filled and tree are mutually exclusive. filled
# AC::Objects should represent complete objects in the backend. tree
# AC::Objects should represent the root node of a subtree. trees, if
# their root node "isObject", should allow for stepping into the
# object via "fetch" or "fill".
sub filled { shift->{filled} }
sub tree   { shift->{tree} }

sub fill { # destructive. fills an unfilled object
    my $self = shift;

    if ( !$self->filled and $self->isObject) {
        my $filled = $self->db->fetch(
            class  => $self->class,
            name   => $self->name,
            filled => 1
        );
        %$self = %$filled;
    }

    return $self;
}

sub fetch { # destructive. fetches an unfilled object if tree
    my $self = shift;

    if ($self->tree and $self->isObject) {
        my $obj = $self->db->fetch($self->id);
        %$self = %$obj;
    }

    return $self;
}

sub isRoot {
    my $self = shift;
    !$self->tree && $self->isObject;
}

sub isTag  { shift->class eq 'tag' }

sub isObject {
    my $self = shift;
    $self->db->isClass($self->class);
}

# works like AcePerl but does not yet support a positional index (WB
# doesn't quite need this, but it can be done)
sub col { # implicitly fills an object
    my $self = shift;
    AC::E::Unimplemented->throw('Positional index not yet supported') if @_;

    $self->fill unless $self->tree;

    return map {
        AceCouch::Object->new_unfilled($self->db, $_)
    }
    grep { !/^_/ }
    keys %{$self->data};
}

# works like AcePerl but won't support right on trees with more than
# one entry i.e. $tree->col > 1 (will throw exception instead of
# randomly returning a subtree)
sub right { # emulate via col
    my $self = shift;
    AC::E::Unimplemented->throw('Positional index not yet supported') if @_;
    # if index = 0, then just return a tree...

    $self->fill unless $self->tree; # if filled already, fill will return

    my @obj_ids = grep { !/^_/ } keys %{$self->data}
        or return;

    AC::E->throw('Ambiguous call to right') if @obj_ids > 1;

    return AceCouch::Object->new_tree(
        $self->db, $obj_ids[0], $self->data->{$obj_ids[0]}
    );
}

# works the same as AcePerl but does not (yet) support \. in path
# parts and will not support indices due to the inherent lack of order
sub at {
    my $self = shift;
    my $path = shift;

    return $self->right unless defined $path;

    $self->fill unless $self->tree; # if filled already, fill will return

    my ($subid, $subhash) = ($self->id, $self->data);
    for my $path_part (split /\./, $path) {
        $subid = "tag~$path_part";
        $subhash = $subhash->{$subid} or last;
    }

    return unless $subhash;

    if (wantarray) { # in list ctx, return subtrees to the right
        return map { AceCouch::Object->new_tree($self->db, $_, $subhash->{$_}) }
                   keys %$subhash;
    }

    return AceCouch::Object->new_tree($self->db, $subid, $subhash);
}

# works the same as AcePerl
sub tags {
    my $self = shift;

    $self->fill unless $self->tree;

    return map { (my $t = $_) =~ s/tag~//; $t }
           grep { /^tag~/ }
           keys %{$self->data};
}

sub row {
    my $self = shift;

    $self->fill unless $self->tree;

    my @row;
    my $obj = $self;
    my $fetch;
    while ($obj) {
        # basically a clone + fetch:
        $fetch = AceCouch::Object->new_unfilled($obj->db, $obj->id);
        push @row, $fetch;
        eval { $obj = $obj->right };
        if (my $e = $@) { ref $e ? $e->rethrow : die $e }
    }

    return @row;
}

sub get {
    my $self = shift;
    my $tag  = shift;
    AC::E::Unimplemented->throw('Positional index not yet supported') if @_;

    # FIXME: somewhat duplicated from the autogenerated accessors
    if ($self->isRoot) { # don't do the bfs, just query the view
        my $tree = eval {
            $self->db->fetch(
                class => $self->class,
                name  => $self->name,
                tree  => 1,
                tag   => $tag,
            );
        };
        if (my $e = $@) {
            return if $e =~ /^404/; # Object not found
            ref $e ? $e->rethrow : die $e;
        }

        if (wantarray) {
            my $data = $tree->data;
            return map { AceCouch::Object->new_tree($self->db, $_, $data->{$_}) }
                   keys %$data;
        }

        return $tree;
    }

    $self->fill unless $self->tree;

    # BFS the tree
    $tag = "tag~$tag";
    my $subhash;
    my @q = ($self->data);
    while ($subhash = shift @q) {
        next unless ref $subhash;
        if ($subhash->{$tag}) {
            $subhash = $subhash->{$tag};
            last;
        }
        push @q, values %$subhash;
    }

    return unless $subhash;

    my $db = $self->db;
    return AceCouch::Object->new_tree($db, $tag, $subhash) unless wantarray;
    return map { AceCouch::Object->new_tree($db, $_, $subhash->{$_}) }
           keys %$subhash;
}

__PACKAGE__
