package AceCouch::Object;

use common::sense;
use AceCouch::Exceptions;

use overload (
    '""'       => 'as_string',
    'fallback' => 'TRUE',
);

BEGIN { *as_string = \&name; }

sub AUTOLOAD {
    our $AUTOLOAD;
    my ($tag) = $AUTOLOAD =~ /.*::(.+)/;
    my $self = shift;

    my ($fill, $tree); # both cannot be true...

    if (defined $_[0]) {
        given($_[0]) {
            when('-fill') { $fill = 1 }
            when(0)       { $tree = 1 }
            default       { AC::E::Unimplemented->throw(
                "Autogenerated accessors do not (yet?) support $_"
            ) }
        }
    }

    return $self->db->fetch(
        class  => $self->class,
        name   => $self->name,
        tag    => $tag,
        filled => $fill,
        tree   => $tree,
    );
}

sub new { # TODO: fix this nastiness
    my ($class, $args) = @_;

    return bless $args, $class;
}

## specific constructors... mild code duplication for now

sub new_unfilled {
    my ($class, $db, $id) = @_;
    my ($c, $n) = split /~/, $id, 2;
    return bless { db => $db, id => $id, data => { class => $c, name => $n } },
                 $class;
}

sub new_filled {
    my ($class, $db, $id, $data) = @_;

    return bless { db => $db, id => $id, filled => 1, data => $data }, $class;
}

sub new_tree {
    my ($class, $db, $id, $data) = @_;
    @{$data}{'class','name'} = split /~/, $id, 2;

    return bless { db => $db, id => $id, filled => 1, tree => 1, data => $data }, $class;
}

sub DESTROY {}

# a few things don't make sense if the object is a subtree

sub id     { shift->{id} }
sub name   { shift->{data}{name} }
sub class  { shift->{data}{class} }
sub data   { shift->{data} }
sub filled { shift->{filled} }
sub tree   { shift->{tree} } # if the obj is filled, is it a tree?
sub db     { shift->{db} }

sub isTag  { shift->class eq 'tag' }
sub isObject {
    shift->class !~ /^(float|int|date|tag|txt|peptide|dna|scalar|[Tt]ext|comment)$/;
}

sub col {
    my $self = shift;
    AC::E::Unimplemented->throw('Positional index not yet supported')
        if @_;

    if ($self->tree) {
        my @obj_ids = keys %{$self->data};

        return @obj_ids if wantarray;

        return map {
            my ($class, $name) = split /~/, $_, 2;
            AceCouch::Object->new({
                db     => $self->db,
                id     => $_,
                filled => undef,
                data   => {
                    class => $class,
                    name  => $name,
                },
            });
        } @obj_ids;
    }

    # fetch the tree structure (whole object)
    $self->db->fetch(
        class => $self->class,
        name  => $self->name,
        fill  => 1,
    );
}

1;
