package AceCouch::Object;

use common::sense;
use AceCouch::Exceptions;

use overload (
    '""'     => 'as_string',
    fallback => 'TRUE',
);

BEGIN {
    *as_string = \&name;
    *isClass   = \&isObject;
}

# TODO: caching results

sub AUTOLOAD {
    our $AUTOLOAD;
    my ($tag) = $AUTOLOAD =~ /.*::(.+)/;
    my $self = shift;

    AC::E::Unimplemented->throw('Using autogenerated accessors on subtrees is not supported/implemented')
        if $self->tree;

    my $fill;

    if (defined $_[0]) {
        given($_[0]) {
            when('-fill') { $fill = 1 }
            default       { AC::E::Unimplemented->throw(
                "Autogenerated accessors do not (yet?) support $_"
            ) }
        }
    }

    my %params = (
        class => $self->class,
        name => $self->name,
        tag => $tag,
        filled => $fill,
    );

    if (wantarray) {
        # does $fill make sense here??
        my $tree = $self->db->fetch(%params, tree => 1);
        my $data = $tree->data;
        return map {
            AceCouch::Object->new_tree($self->db, $_, $data->{$_});
        }
        grep { $_ !~ /^(class|name|_)/ }
        keys %$data;
    }

    return $self->db->fetch(%params);
}

sub new { # TODO: fix this nastiness
    my ($class, $args) = @_;

    return bless $args, $class;
}

## specific constructors... mild code duplication for now

sub new_unfilled {
    my ($class, $db, $id) = @_;
    my ($c, $n) = split /~/, $id, 2;
    return bless { db => $db, id => $id, data => { class => $c, name => $n } },
                 $class;
}

sub new_filled {
    my ($class, $db, $id, $data) = @_;

    return bless { db => $db, id => $id, filled => 1, data => $data }, $class;
}

sub new_tree {
    my ($class, $db, $id, $data) = @_;
    @{$data}{'class','name'} = split /~/, $id, 2; # even trees have names and classes...

    return bless { db => $db, id => $id, tree => 1, data => $data }, $class;
}

sub DESTROY {}

# a few things don't make sense if the object is a subtree

sub id     { shift->{id} }
sub name   { shift->{data}{name} }
sub class  { shift->{data}{class} }
sub data   { shift->{data} }
sub db     { shift->{db} }

# convention: filled and tree are mutually exclusive. filled
# AC::Objects should represent complete objects in the backend. tree
# AC::Objects should represent the root node of a subtree. trees, if
# their root node "isObject", should allow for stepping into the
# object via "fetch" or "fill".
sub filled { shift->{filled} }
sub tree   { shift->{tree} }

sub fill { # destructive. fills an unfilled object
    my $self = shift;

    if ( !$self->filled and $self->isObject) {
        my $filled = $self->db->fetch(
            class  => $self->class,
            name   => $self->name,
            filled => 1
        );
        %$self = %$filled;
    }

    return $self;
}

sub fetch { # destructive. fetches an unfilled object if tree
    my $self = shift;

    if ($self->tree and $self->isObject) {
        my $obj = $self->db->fetch($self->id);
        %$self = %$obj;
    }

    return $self;
}

sub isTag  { shift->class eq 'tag' }
sub isObject {
    my $self = shift;
    $self->db->isClass($self->class);
}

sub col { # implicitly fills an object
    my $self = shift;
    AC::E::Unimplemented->throw('Positional index not yet supported') if @_;

    if ($self->tree or $self->filled) {
        # FIXME: look at grep; there must be a better way. data restructure?
        return map {
            AceCouch::Object->new_unfilled($self->db, $_)
        }
        grep { $_ !~ /^(class|name|_)/ }
        keys %{$self->data};
    }

    # neither tree nor filled, i.e. unfilled object
    $self->fill->col;
}

sub right { # emulate via col
    my $self = shift;
    AC::E::Unimplemented->throw('Positional index not yet supported') if @_;
    # if index = 0, then just return a tree...

    $self->fill unless $self->tree; # if filled already, fill will return

    my @obj_ids = grep { $_ !~ /^(class|name|_)/ } keys %{$self->data}
        or return;

    AC::E->throw('Ambiguous call to right') if @obj_ids > 1;

    return AceCouch::Object->new_tree(
        $self->db, $obj_ids[0], $self->data->{$obj_ids[0]}
    );
}

sub at { # this doesn't require emulation :)
    my $self = shift;
    my $path = shift;

    $self->fill unless $self->tree; # if filled already, fill will return

    my ($subid, $subhash) = ($self->id, $self->data);
    for my $path_part (split /\./, $path) {
        $subid = "tag~$path_part";
        $subhash = $subhash->{$subid} or last;
    }

    return AceCouch::Object->new_tree($self->db, $subid, $subhash) if $subhash;
    return;
}

sub tags {
    AC::E::Unimplemented->throw('TODO');
    ...
}

__PACKAGE__
